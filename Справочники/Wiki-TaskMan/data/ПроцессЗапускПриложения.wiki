++ Процесс Запуск Приложения
[template: ШаблонСтраницыРазделаКонцепции]
Состояние: [В РАЗРАБОТКЕ]

+++Ссылки раздела
* ГлоссарийОператор


+++Содержание раздела



+++Материалы
* Процесс запуска, в целом, как в Оператор.
* Приложение запускается пользователем либо автоматически при автозагрузке ОС.
* Приложение не проверяет, что оно единственное запущенное приложение, поскольку можно открыть по одному приложению для каждого Хранилища Задач.
* Приложение создает объект Движка, вызвав конструктор Движка. Этот объект хранится в течение всего сеанса работы приложения.
* Приложение из настроек приложения извлекает значение флага Использовать указанное Хранилище Задач. 
    * Если флаг не установлен, приложение показывает главную форму и ожидает команду пользователя, которую он должен подать, выбрав один из пунктов меню.
    * Если же флаг установлен, то приложение извлекает из настроек приложения путь к последнему использованному Хранилищу Задач. Далее переход к пункту Открытие Хранилища.
* Открытие Хранилища: Приложение проверяет, что путь к каталогу хранилища существует.
    * Если это не так, приложение выводит сообщение об ошибке: каталог Хранилища не существует. Затем приложение возвращается в цикл ожидания команд пользователя для главного окна приложения. Открытие Хранилища прервано.
    * Если каталог Хранилища существует, приложение проверяет, что указанный каталог это Каталог Хранилища, вызывая статическую функцию движка IsStorageFolder(..)
        * Если функция возвращает false, то выбрасывается ошибка Каталог не является Хранилищем или Хранилище повреждено. Затем приложение возвращается в цикл ожидания команд пользователя для главного окна приложения. Открытие Хранилища прервано.
    * Каталог проверяется на возможность записи в него. Соответственно выбирается значение флага readOnly как флаг из настроекХранилища ИЛИ реальная возможность записи в каталогХранилища. 
        * todo: уточнить всю эту схему выбора readOnly: место и способ.
    * Если это точно каталог Хранилища, приложение вызывает функцию Движка StorageOpen(путь к каталогу хранилища, флаг readOnky)
        * Если флаг readOnly=true, то Хранилище открывается в режиме только для чтения, любое изменение в нем невозможно и выбрасывает ошибку.
    * Движок проверяет, что Хранилище не открыто уже, проверив существование временного файла сеанса в КаталогХранилищаЗадач. Этот код можно взять из Оператор нового проекта.
        * Если Хранилище уже открыто, Движок выбрасывает ошибку Хранилище уже открыто другим процессом.  Затем приложение возвращается в цикл ожидания команд пользователя для главногоокна приложения. Открытие Хранилимща прервано.
        * Если Хранилище было открыто в режиме readOnly, временный файл сеанса не создается. Проверка монопольного доступа к Хранилищу не производится. Изменения не могут быть записаны, поэтому и монопольный доступ не имеет значения.
    * Движок находит и загружает файл свойств Хранилища из Каталога Хранилища.
        * то есть, инициализирует объект свойств Хранилища. 
    * Если флаг readOnly не установлен, Движок удаляет старый бекап файла БД и создает новый бекап как копию еще не открытого файла БД.
        * Это может занять несколько десятков секунд для большой БД, хорошо бы как-то это отразить в строке состояния приложения, или показать диалог прогресса на время открытия Хранилища приложением. 
        * Это должен делать FSM объект. 
    * Движок инициализирует подсистемы в правильном порядке:
        * объект свойств Хранилища уже загружен.
        * менеджера лога в этой версии нет, а то он бы первым должен быть инициализирован, чтобы записывать события в лог.
        * объект менеджер каталога Хранилища, так как БД нужен путь к файлу, а он берется из менеджера каталога Хранилища. 
            * инициализация - это вызов метода Open(...), а завершение - вызов метода Close().
            * следует взять базовый класс менеджера подсистемы из Оператор, чтобы везде в менеджерах подсистем были эти Open() Close() правильные.
                * А он не подходит, там в Open() нельзя аргументы передавать, только через проперти. Поэтому он только как пример устройства.   
        * объект БД Хранилища, по пути к файлу БД.
        * менеджер идентификаторов элементов передав ему максимальный имеющийся идентификатор элемента, извлеченный из таблицы элементов БД.
        * далее еще что-то и считаем, Хранилище успешно открыто.
* если приложение получает исключение, оно выводит его пользователю в виде Message Box и возвращается к ожиданию команды впользователя для главного окна приложения.
* Когда Хранилище успешно открыто: 
    * приложение читает из БД записи и собирает из них ДеревоЗадач в левой половине главного окна приложения.
    * приложение запускает процесс построения списка Сегодня.
    * приложение обновляет строку состояния главного окна 
    * приложение ожидает команду пользователя.   
* БД всегда нормально должна быть закрытой, чтобы избежать повреждения во время работы приложения. Но если повреждение возникнет при аварийном завершении приложения, пользователь должен сам заменить файл Бд его бекап-копией. При этом, он потеряет изменения за прошлый сеанс, но это все же не целиком все данные БД. 
        
           