Основная идея модели состоит в том, что Пользователь задает набор Показателей рабочей среды, устанавливает их значения, и автоматическая система балансирует задания так, 
 чтобы: 
- добиться достижения и поддержания заданного состояния рабочей среды; 
- избегать падения/возрастания показателя ниже минимально/максимально допустимого предела;
- уменьшать количество работы по достижению и поддержанию заданного состояния рабочей среды;
- накапливать опыт и оптимизировать методы изменения состояния рабочей среды.

++Показатель

Показатели это показатели состояния системы: какой уровень, сколько единиц должно быть в системе по каждому важному параметру рабочей среды.
Целевые параметры среды, которую эта модель представляет/которой эта модель управляет, чтобы поддерживать эту среду в таком состоянии.

Показатель представляет собой некий числовой показатель состояния рабочей среды: 16 пар носков, 10 бутылок водки в холодильнике, 8 банок соленых огурцов в погребе, 8 видов круп в кухонном шкафу, итп.
Показатель создается Пользователем для контроля состояния рабочей среды.
 - но Пользователь не желает каждый день пересчитывать количество носков и бутылок водки в холодильнике.
    - Поэтому он должен будет пересчитывать их регулярно через выбранные им интервалы времени.
       В этом случае модель будет немного неправильно работать в краткосрочном масштабе, но правильно в целом.
       А если автоматизировать обновление всех показателей, то пользоваться этой системой будет приятнее. 
Показатели должны быть выбраны правильно, чтобы отражать важные признаки состояния рабочей среды.
 Например, цель Пользователя - более лучше питаться. Тут показателем будет Количество видов еды, а не Количество еды.
 А лучше - и то, и другое, два Показателя для еды.
Показатель должен быть добавлен Пользователем. Неправильно будет задавать Показатели в коде проекта, кроме как для тестирования системы.

А еще, можно ввести Классы показателей, чтобы обрабатывать Показатели по установленным Пользователем правилам. 

И сейчас совсем не определено, как реализовать методы подсчета значений Показателей из реального мира. 
 Эта важная и увлекательная часть проекта пока не рассматривается, поскольку не до нее сейчас.
  Сейчас Пользователь вносит новое текущее значение Показателя в программу и все на этом.

Показатели можно представить как набор шкал с ползунками, с помощью которых пользователь может видеть текущее значение каждого показателя и установить требуемое значение показателя.
- хорошо бы представить на форме показатель одним контролом как комбинацию из ProgressBar и линейного регулятора - забыл как называется. 
  И контролы ввода значений нужны: 3 или 4 штуки для типа Double.


Показатель может быть реализован как тип С/C# Double.
Но так будет слишком просто, а мы тут не ищем легких путей. Поэтому Показатель должен быть реализован более сложно.
- Показатель должен иметь свойство Уникальный идентификатор. Это единый уникальный идентификационный номер объектов в системе, согласно УАМХ.
- Показатель должен иметь свойство Название. Например: Обеспеченность средствами снятия абстинентного синдрома.
- Показатель должен иметь свойство Описание. Например: Количество бутылок водки в заначке.
- Показатель должен иметь свойство текущего значения, которое отражает текущий уровень показателя в единицах измерения.
  * TODO: придумать название для текущего значения Показателя.
- Показатель обозначает Состояние, которое необходимо достичь или удерживать. 
   Поэтому он должен иметь свойство Норма, которое отражает ожидаемое или достигнутое состояние рабочей среды в единицах измерения.
- Показатель должен иметь свойство Единицы измерения, которое описывает используемые единицы измерения для вывода Пользователю правильно сформированного текста.
- Показатель должен иметь свойство Хорошо, которое содержит предельное значение, лучшее, чем Норма.
  Не большее, а именно лучшее. Так как иногда лучше меньше, да лучше.
- Показатель должен иметь свойство Плохо, которое содержит предельное значение, худшее, чем Норма.
Для типа Double предельное значение будет, вероятно, Double.MaxValue или Double.MinValue.
Для каждого Показателя Пользователь должен установить значения Плохо, Норма, Хорошо:
- Плохо < Норма < Хорошо для Позитивного показателя, например, Количество еды.
- Плохо > Норма > Хорошо для Негативного показателя, например, Количество задач.
А чтобы код мог выполнять сравнения Показателей, и чтобы читатель этого текста совсем запутался, и не вздумал скопипастить всю идею целиком, мы и тут не ищем легких путей.
По примеру деятелей науки и общества, доцентов с кандидатами, необходимо весь практически ценный теоретический механизм подать в извращенно-обфусцированной форме ссылок на собственные статьи и цитат из них же невпопад и не по теме.
Однако, я надеюсь, никто читать этот текст не будет, кроме меня самого. 

++Оценка
Для возможности сравнивать значения Показателей и быстро выбирать из них наилучший-наихудший, предлагается ввести Оценки.
Оценка это продукт сложного тригонометрического преобразования X = f(Плохо, Норма, Хорошо, Y); где Y - текущее значение показателя. 
Результат X должен находиться в пределах -1..0..1, когда Y находится в пределах Плохо..Хорошо.
Результат X = 0, когда Y = Норма.
Результат Х может быть вне пределов -1..0..1 (но не более, чем Double.MinValue..Double.MaxValue), когда Y находится вне пределов Плохо..Хорошо ( но не более, чем Double.MinValue..Double.MaxValue).
В таком виде Оценки можно использовать как входные данные для нейросети, но в проекте никаких нейросетей не будет, как минимум, в первой версии проекта.
Обратное преобразование Оценки в исходные значения не требуется, и в архитектуре проекта следует избегать такой необходимости.
Поскольку разброс значений у разных Показателей очень большой, то надо использовать логарифмическую шкалу. Линейная шкала явно не подходит.
Для всех Показателей следует использовать один и тот же метод формирования Оценки, чтобы их можно было сравнивать без больших ошибок.
Но какой именно - я пока не знаю.
* TODO: Найти, где можно добыть такую формулу для расчетов Оценки. 
- Использовать разность Оценок между Есть и Надо - непонятно, сколько именно надо в единицах измерения. 
  Так как шкала логарифмическая, из такой разности не следует количество.
  Поэтому для Задач надо передавать количественную разность Надо минус Есть.
   Например: "Задача: пополнить запасы водки на 8 бутылок."
- вообще, Оценки не необходимы в этой версии модели. Но надо их попробовать, чтобы оценить, для чего и как их можно использовать.
  - Оценки предоставляют быстрый единообразный способ оценки Задач в общем списке Задач.
    Для Задач следует передавать также Оценку (Текущего состояния Показателя относительно Норма), чтобы оценить интенсивность Задачи.
    Но это тоже пока непонятно, что, как и для чего использовать.


++Идеи кучей
1. Следует на время прототипирования реализовать Показатель как словарь ключ-значение.
Поскольку у него много полей выявляется по мере проработки темы.
- Хранить данные Показателя в таблице БД в виде ключ-значение.
- Показатель оформить как элемент УАМХ, если не будет препятствий.
2. Нужна Оценка актуальности значения Показателя, поскольку сам Показатель является кешем значения из реального мира.
Это значение со временем может устареть.
И новое значение Показателя должен вводить Пользователь в ходе выполнения Задачи обновления Показателя.
Обновление значения Показателя пользователем, в зависимости от вида Показателя, возможно лишь с периодичностью 1 неделю или 1 месяц.
- нужно свойство Показателя: Таймштамп - содержит дату внесения данных.
- нужно свойство Показателя: Оценка актуальности данных Показателя.
  Пределы оценки устанавливать:
   А) индивидуально для каждого Показателя;
   Б) общим для всех Показателей;
3. Нужна Оценка достоверности данных Показателя, поскольку эти данные бывают получены из недостоверных источников или недостаточно проверенным на правильность способом.
- нужно свойство Показателя: Оценка достоверности данных Показателя.
  Пределы оценки устанавливать:
   А) индивидуально для каждого Показателя;
   Б) общим для всех Показателей;
4. Эти оценки из пунктов 2 и 3 следует реализовать как-то выделенно, вынести механизм оценки в отдельный класс или набор данных?
5. Эти оценки из пунктов 2 и 3 не необходимы для первой версии приложения, они добавляют гибкости для разрабатываемой модели.
    Они также увеличивают сложность модели.
    Но пока что я не знаю, как их использовать, они могут пригодиться позже.
 
